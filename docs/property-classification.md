# Property classification

Property classification allows you to inspect the distribution of test data generated by your properties. This helps you understand whether your generators are producing realistic data distributions and whether edge cases are being adequately tested.

## Overview

Hedgehog provides two mechanisms for understanding your test data:

- **Classification** - Categorize test inputs into named groups
- **Collection** - Gather numerical statistics from test inputs

When you use either mechanism, property test results will include distribution statistics alongside pass/fail information.

## Basic usage

### Classification

Use `.classify()` to categorize test inputs:

```rust
use hedgehog::*;

let prop = for_all(Gen::int_range(-10, 10), |&x| x >= -10 && x <= 10)
    .classify("negative", |&x| x < 0)
    .classify("zero", |&x| x == 0)
    .classify("positive", |&x| x > 0);

let result = prop.run(&Config::default());
println!("{}", result);
```

Output:
```
✓ property passed 100 tests.

Test data distribution:
  45% negative
   3% zero
  52% positive
```

### Collection

Use `.collect()` to gather numerical statistics:

```rust
let prop = for_all(Gen::vec_int(), |vec| vec.len() < 1000)
    .collect("length", |vec| vec.len() as f64)
    .collect("sum", |vec| vec.iter().sum::<i32>() as f64);

let result = prop.run(&Config::default());
println!("{}", result);
```

Output:
```
✓ property passed 100 tests.

Test data statistics:
  length: min=0.0, max=47.0, avg=12.3, median=8.0
  sum: min=-890.0, max=1250.0, avg=45.2, median=12.0
```

## Combining classification and collection

You can use both mechanisms together:

```rust
let prop = for_all(Gen::string(), |s| !s.contains("forbidden"))
    .classify("empty", |s| s.is_empty())
    .classify("short", |s| s.len() < 10)
    .classify("long", |s| s.len() >= 20)
    .collect("length", |s| s.len() as f64)
    .collect("vowel_count", |s| {
        s.chars().filter(|c| "aeiouAEIOU".contains(*c)).count() as f64
    });
```

Output:
```
✓ property passed 100 tests.

Test data distribution:
  23% empty
  67% short
   8% long

Test data statistics:
  length: min=0.0, max=45.0, avg=8.9, median=6.0
  vowel_count: min=0.0, max=12.0, avg=3.2, median=3.0
```

## Use cases

### Validating generator distributions

Ensure your generators produce realistic data:

```rust
// Test that HTTP status codes have reasonable distribution
let prop = for_all(Gen::http_status(), |&status| is_valid_status(status))
    .classify("success", |&s| s >= 200 && s < 300)
    .classify("redirect", |&s| s >= 300 && s < 400)
    .classify("client_error", |&s| s >= 400 && s < 500)
    .classify("server_error", |&s| s >= 500);
```

### Identifying edge case coverage

Check whether important edge cases are being tested:

```rust
let prop = for_all(Gen::vec_int(), |vec| sort_is_stable(vec))
    .classify("empty", |vec| vec.is_empty())
    .classify("singleton", |vec| vec.len() == 1)
    .classify("already_sorted", |vec| is_sorted(vec))
    .classify("reverse_sorted", |vec| is_reverse_sorted(vec))
    .classify("has_duplicates", |vec| has_duplicates(vec));
```

### Performance characteristic validation

Monitor performance-related properties:

```rust
let prop = for_all(Gen::large_input(), |input| {
    let start = Instant::now();
    let result = expensive_operation(input);
    let duration = start.elapsed();
    
    duration < Duration::from_millis(100) // Performance target
}).collect("duration_ms", |input| {
    let start = Instant::now();
    expensive_operation(input);
    start.elapsed().as_millis() as f64
});
```

## API reference

### `Property::classify`

```rust
pub fn classify<F>(self, name: &str, predicate: F) -> Self
where
    F: Fn(&T) -> bool + 'static
```

Adds a classification to categorize test inputs.

- `name`: The name for this classification category
- `predicate`: Function that returns `true` if the input belongs to this category

### `Property::collect`

```rust
pub fn collect<F>(self, name: &str, extractor: F) -> Self
where
    F: Fn(&T) -> f64 + 'static
```

Adds a collection to gather numerical statistics from test inputs.

- `name`: The name for this statistic
- `extractor`: Function that extracts a numerical value from the input

### `TestStatistics`

```rust
pub struct TestStatistics {
    pub classifications: HashMap<String, usize>,
    pub collections: HashMap<String, Vec<f64>>,
    pub total_tests: usize,
}
```

Contains the statistics gathered during property testing:

- `classifications`: Count of inputs in each classification category
- `collections`: All collected values for each named statistic
- `total_tests`: Total number of tests run

## Best practices

### Classification naming

Use descriptive, concise names for classifications:

```rust
// Good
.classify("empty", |vec| vec.is_empty())
.classify("small", |vec| vec.len() < 10)
.classify("large", |vec| vec.len() > 100)

// Avoid
.classify("c1", |vec| vec.is_empty())
.classify("length_is_less_than_ten", |vec| vec.len() < 10)
```

### Meaningful statistics

Collect statistics that provide actionable insights:

```rust
// Useful statistics
.collect("length", |s| s.len() as f64)
.collect("complexity", |data| calculate_complexity(data))
.collect("memory_usage", |input| measure_memory_usage(input))

// Less useful
.collect("hash", |s| hash(s) as f64) // Random numbers aren't insightful
```

### Multiple classifications

An input can belong to multiple classifications:

```rust
let prop = for_all(Gen::int_range(1, 100), |&x| x > 0)
    .classify("small", |&x| x < 10)      // 1-9
    .classify("medium", |&x| x < 50)     // 1-49 (overlaps with small)
    .classify("large", |&x| x >= 50)     // 50-100
    .classify("even", |&x| x % 2 == 0)   // All even numbers
    .classify("prime", |&x| is_prime(x)); // All prime numbers
```

This produces output like:
```
Test data distribution:
  42% small
  67% medium  
  33% large
  48% even
  23% prime
```

Note that percentages can sum to more than 100% when categories overlap.